{
  "name": "lyrix_component",
  "type": "registry:block",
  "dependencies": [
    "@emotion/react",
    "bouzidanas/react-use-precision-timer"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "lyr-ix/Lyrix.tsx",
      "content": "/** @jsxImportSource @emotion/react */\nimport { css as CSS, Global } from '@emotion/react'\nimport { useEffect, useRef, useState, forwardRef, useImperativeHandle, useCallback, useId } from 'react';\nimport type { CSSObject } from '@emotion/react';\nimport { useTimer } from 'react-use-precision-timer';\nimport { lrcTimestampRegex, processLrcLyrics } from '../lib/processLRC';\nconst googleFonts = `@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap');`\nexport type ActionsHandle = {\n  play: () => void;\n  pause: () => void;\n  isPlaying: () => boolean;\n}\nexport interface LyrixProps {\n  lyrics: string;\n  className?: string;\n  css?: string | CSSObject;\n  start?: number;\n  highlightColor?: string;\n  timestamps?: number[];\n  height?: string;\n  fade?: boolean;\n  fadeStop?: string;\n  trailingSpace?: string;\n  readScrollRatio?: number;\n  theme?: 'inherit' | 'spotify' | 'lyrix';\n  scale?: number;\n  delayEnd?: number;\n  disableInteractivity?: boolean;\n  onPlay?: (time: number) => void;\n  onPause?: () => void;\n  onUserLineChange?: (line: number, time: number) => void;\n  onLineChange?: (line: number, time: number) => void;\n}\nexport const Lyrix = forwardRef<ActionsHandle, LyrixProps>(function Lyrix({ lyrics, className = '', css = {}, start = 0, highlightColor = '#ffffffbb', height = '', fadeStop = '10ex', trailingSpace = '10rem', timestamps = undefined, readScrollRatio = 1, scale = 1, theme = 'inherit', delayEnd = 10000, disableInteractivity = false, onPause = undefined, onPlay = undefined, onUserLineChange = undefined, onLineChange = undefined }: LyrixProps, ref){\n  const [lyricsArray] = useState<string[]>(lrcTimestampRegex.test(lyrics) ? processLrcLyrics(lyrics).processedLines : lyrics.split('\\n'));\n  const [currentLine, setCurrentLine] = useState<number>(start);\n  const lId = useRef<string>('lyr-ix' + useId());\n  // const callbackAfterRender = useRef<number>(0);\n  // If timestamps are not provided, look for them in the lyrics (lrc format)\n  const timeStamps = timestamps ?? lrcTimestampRegex.test(lyrics) ? processLrcLyrics(lyrics).timestamps : undefined;\n  \n  // Calculate time deltas ie. time between highlighting each line of the lyrics\n  const timeDeltas = timeStamps?.map((timestamp, index) => index + 1 < timeStamps.length? (timeStamps[index + 1] - timestamp) * 1000 : delayEnd);\n  \n  // Callback function for the timer to call at the end of the delay\n  const callback = useCallback(() => setCurrentLine(currentLine => currentLine < lyricsArray.length - 1 ? currentLine + 1 : currentLine), [lyricsArray.length]);\n    \n  // Create the timer\n  const timerRef = useRef(useTimer({ delay: timeDeltas}, callback));\n  \n  const startTimer = useCallback(() => {\n    timerRef.current.start(undefined, currentLine);\n  }, [currentLine]);\n  \n  const pauseTimer = () => {\n    timerRef.current.stop();\n  }\n  // Expose the timer's play and pause methods to the parent component\n  // -------------------------------------------------------------------\n  // I dont know how expensive setting the ref is, but if it is expensive\n  // note that the ref needs to be updated only when currentLine changes.\n  // The current assumption is that setting the ref is not expensive so\n  // the ref is set every render.\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      startTimer();\n      if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n    },\n    pause: () => {\n      pauseTimer();\n      if (onPause) onPause();\n    },\n    isPlaying: () => timerRef.current.isRunning(),\n  }));\n  \n  // Create a keydown event listener to pause/play the timer \n  // (and handle cleanup when the component unmounts)\n  useEffect(() => {\n    if (disableInteractivity) return;\n    function handleKeyDown(e: KeyboardEvent) {\n      if (e.key === ' ' || e.key === 'Spacebar') {\n        e.preventDefault();\n        if (timerRef.current.isRunning()) {\n          pauseTimer();\n          if (onPause) onPause();\n        } else {\n          startTimer();\n          if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n        }\n      }\n      else if (e.shiftKey && e.key === 'Enter') {\n        const lyricsElement = document.getElementById(lId.current);\n        if (e.repeat) {\n          lyricsElement?.scrollTo({ top: lyricsElement.scrollTop - lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n        } else {\n          lyricsElement?.scrollTo({ top: lyricsElement.scrollTop - lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n        }\n      }\n      else if (e.key === 'Enter') {\n        const lyricsElement = document.getElementById(lId.current);\n        lyricsElement?.scrollTo({ top: lyricsElement.scrollTop + lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n      }\n      \n      if (e.repeat) {\n        if (e.key === 'Enter'){\n          const lyricsElement = document.getElementById(lId.current);\n          if (e.shiftKey) {\n            lyricsElement?.scrollTo({ top: lyricsElement.scrollTop-=200, behavior: 'auto' });\n          }\n          else {\n            lyricsElement?.scrollTo({ top: lyricsElement.scrollTop+=200, behavior: 'auto' });\n          }\n        }\n      }\n    }\n    document.addEventListener('keydown', handleKeyDown);\n    \n    // Clean up\n    return function cleanup() {\n      document.removeEventListener('keydown', handleKeyDown);\n    }\n  }, [currentLine, timeStamps, onPause, onPlay, startTimer, disableInteractivity]);\n  \n  // Scrolling logic: Scroll to keep the current line in the\n  // desired visible range.\n  // -------------------------------------------------------------------\n  // When the next line that is about to be highlighted exceeds\n  // the readScrollRatio of the height of the lyrics element\n  // the lyrics content must be scrolled down such that the current line\n  // is at the (1-readScrollRatio) of the height of the lyrics element.\n  useEffect(() => {\n    const lyricsElement = document.getElementById(lId.current);\n    const lineElements = document.getElementsByClassName('line');\n    \n    if (lyricsElement && lineElements.length > 0 && lineElements.length === lyricsArray.length && currentLine < lyricsArray.length - 1) {\n      const lyricsClientRects = lyricsElement.getClientRects();\n      const lineClientRects = lineElements[currentLine].getClientRects();\n      const nextLineClientRects = lineElements[currentLine + 1].getClientRects();\n      if (nextLineClientRects[0].bottom > (lyricsClientRects[0].top + readScrollRatio * lyricsClientRects[0].height)) {\n        lyricsElement.scrollTo({ top: lyricsElement.scrollTop + (lineClientRects[0].top - lyricsClientRects[0].top) - (1.0 - readScrollRatio) * lyricsClientRects[0].height, behavior: 'smooth' });\n      }\n      else if (lineClientRects[0].bottom < (lyricsClientRects[0].top + (1.0 - readScrollRatio) * lyricsClientRects[0].height)) {\n        lyricsElement.scrollTo({ top: lyricsElement.scrollTop + (lineClientRects[0].top - lyricsClientRects[0].top) - (1.0 - readScrollRatio) * lyricsClientRects[0].height, behavior: 'smooth' });\n      }\n    }\n  }, [currentLine, lyricsArray.length, readScrollRatio]);\n  \n  // // Warning: Callbacks functions should not be executed during this component's render phase\n  // // because they may cause parent component to re-render at the same time which is\n  // // known to be a source of problems. \n  // // The following useEffect is used to execute pending `onPlay`and `onPause`callbacks after render.\n  // // This is necessary for when the timer is started or paused inside the render phase, ie where the \n  // // callbacks should not be directly called from.\n  // useEffect(() => {\n  //   if (callbackAfterRender.current > 0) {\n  //     if (callbackAfterRender.current === 1) {\n  //       callbackAfterRender.current = 0;\n  //       if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n  //     } else if (callbackAfterRender.current === 2) {\n  //       callbackAfterRender.current = 0;\n  //       if (onPause) onPause();\n  //     }\n  //   }\n  // });\n  \n  // Execute the onLineChange callback when `currentLine` changes after render using useEffect.\n  // Warning: Callbacks functions should not be executed during this component's render phase\n  // because they may cause parent component to re-render at the same time which is\n  // known to be a source of problems.\n  useEffect(() => {\n    onLineChange && onLineChange(currentLine, timeStamps && timeStamps.length > currentLine ? timeStamps[currentLine] : -1);\n  }, [currentLine]);\n  \n  // Add default CSS in an overideable way\n  const completeCSS = typeof css === 'string' ? `display: flex;\n  flex-direction: column;\n  height: ${height};\n  overflow-y: scroll;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0));\n  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0));\n  & div.line.current {\n    color: ${highlightColor};\n    filter: none;\n}\n${disableInteractivity ? '' : `& div.line:hover {\n  color: ${highlightColor};\n  filter: none;\n  opacity: 1\n}\n`}\n&::-webkit-scrollbar {\n  display: none;\n}\n${theme === 'spotify' ? `& div.line {\n  font-family: 'Heebo', sans-serif;\n  font-size: ${Math.round(scale*20)/10}rem;\n  font-weight: 700;\n  line-height: ${Math.round(scale*24)/10}rem;\n  letter-spacing: -.01em;\n  color: #000000a2;\n  text-align: left;\n  padding-top: ${scale}rem;\n  padding-bottom: ${scale}rem;\n}` : (theme === 'lyrix' ? `& div.line {\n  font-family: 'Roboto', sans-serif;\n  font-size: ${Math.round(scale*20)/10}rem;\n  font-weight: 700;\n  line-height: ${Math.round(scale*24)/10}rem;\n  letter-spacing: -.01em;\n  color: #ffffff;\n  text-align: left;\n  padding-top: ${scale}rem;\n  padding-bottom: ${scale}rem;\n  opacity: 0.2;\n  filter: blur(1px);\n}` : '')}\n${css}` : { display: 'flex', flexDirection: 'column', height: height, overflowY: 'scroll', msOverflowStyle: 'none', scrollbarWidth: 'none', WebkitMaskImage: `linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0))`, maskImage: `linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0))`, '& div.line.current': { color: highlightColor, filter: 'none', opacity: 1}, '& div.line:hover': disableInteractivity ? undefined : { color: highlightColor, filter: 'none', opacity: 1 }, '&::-webkit-scrollbar': { display: 'none' }, '& div.line': theme === 'spotify' ? { fontFamily:'\"Heebo\", sans-serif', fontSize: Math.round(scale*200)/100 + 'rem', fontWeight: '700', lineHeight: Math.round(scale*240)/100 + 'rem', letterSpacing: '-0.01em', color: '#000000a2', textAlign: 'left', paddingTop: scale + 'rem', paddingBottom: scale + 'rem' } : (theme === 'lyrix' ? { fontFamily:'\"Roboto\", sans-serif', fontSize: Math.round(scale*200)/100 + 'rem', fontWeight: '700', lineHeight: Math.round(scale*240)/100+'rem', letterSpacing: '-0.01em', color: '#ffffff', textAlign: 'left', paddingTop: scale+'rem', paddingBottom: scale+'rem', opacity: 0.2, filter: 'blur(1px)' } : {}), ...css } as CSSObject;\nreturn (\n  <div id={lId.current} className={'lyrics ' + className} css={CSS(completeCSS)} >\n      <Global styles={CSS(googleFonts)} />\n      <div key='space-before' className='spacer' css={CSS({ minHeight: trailingSpace })}></div>\n      {lyricsArray.map((line, index) => (\n        <div\n        key={index}\n        className={'line ' + (index === currentLine ? 'current' : (index < currentLine ? 'past' : 'future'))}\n        onClick={() => {\n          if (disableInteractivity) return;\n          if (currentLine === index) {\n            if (timerRef.current.isRunning()) {\n              pauseTimer();\n              if (onPause) onPause();\n              } else {\n                startTimer();\n                if (onPlay && timeStamps && timeStamps.length > index) onPlay(timeStamps[index]);\n              }\n            } else {\n              pauseTimer();\n              if (onPause) onPause();\n              setCurrentLine(index);\n              if (onUserLineChange) onUserLineChange(index, timeStamps && timeStamps.length > index ? timeStamps[index] : -1);\n            }\n          }}\n          dangerouslySetInnerHTML={{ __html: line.trim()}} \n        />\n      ))}\n      <div key='space-after' className='spacer' css={CSS({ minHeight: trailingSpace })}></div>\n    </div>\n  );\n});\n",
      "type": "registry:component"
    },
    {
      "path": "lyr-ix/processLRC.ts",
      "content": "export const lrcTimestampRegex = /\\[(\\d{2}):(\\d{2})\\.(\\d{2,3})\\]/g;\n// Convert LRC lyrics to timestamps and processed lines\nexport const processLrcLyrics = (lyrics: string) => {\n    const lines = lyrics.split('\\n');\n    const timestamps: number[] = [];\n    const processedLines: string[] = [];\n  \n    lines.forEach(line => {\n      const match = lrcTimestampRegex.exec(line);\n      if (match) {\n        timestamps.push((parseInt(match[1]) * 60 * 1000 + parseInt(match[2]) * 1000 + parseInt(match[3])*10) / 1000);\n        processedLines.push(line.replace(lrcTimestampRegex, '').trim());\n      }\n    });\n  \n    return { timestamps, processedLines };\n  }",
      "type": "registry:util"
    }
  ],
  "tailwind": {},
  "cssVars": {},
  "meta": {
    "importSpecifier": "Lyrix",
    "moduleSpecifier": "@/components/Lyrix",
    "nextVersion": "14.2.16"
  },
  "docs": "Placeholder for LyrixCard component"
}
