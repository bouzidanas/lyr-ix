{
  "name": "lyrix_card_component",
  "type": "registry:block",
  "dependencies": [
    "@emotion/react",
    "react-icons",
    "bouzidanas/react-use-precision-timer"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "LyrixCard.tsx",
      "content": "import { forwardRef, useImperativeHandle, useRef, useState } from 'react';\nimport { Lyrix, ActionsHandle } from './Lyrix';\nimport { HiOutlinePlay, HiOutlinePause, HiOutlineSpeakerWave, HiOutlineSpeakerXMark } from 'react-icons/hi2'\nimport { lyrics } from '../lib/the-awakening';\nexport type LyrixCardElement = {\n  play: () => void;\n  pause: () => void;\n  load: () => void;\n  isPlaying: () => boolean;\n}\nexport interface LyrixCardProps {\n  title?: string;\n  lrc?: string;\n  src?: string;\n  height?: string;\n  className?: string;\n  theme?: 'lyrix' | 'inherit' | 'spotify' | undefined;\n  highlightColor?: string;\n  start?: number;\n  trailingSpace?: string;\n  fadeStop?: string;\n  scrollRatio?: number;\n  mute?: boolean;\n  disablePlayButton?: boolean;\n  disableMuteButton?: boolean;\n  lyricsScale?: number;\n  controlsScale?: number;\n  endingDelayBuffer?: number;\n  onLineChange?: (line: number) => void;\n  onPlay?: (time: number) => void;\n  onPause?: () => void;\n  onEnd?: () => void;\n}\nexport const LyrixCard = forwardRef<LyrixCardElement, LyrixCardProps>(function LyrixCard({ title='The Awakening - Onlap', lrc=lyrics, src='/ONLAP - The Awakening.mp3', height='62vh', className='', theme='lyrix', highlightColor='#ffffffbb', start=0, trailingSpace='0rem', fadeStop='0%', scrollRatio=1, lyricsScale=1, controlsScale=1, endingDelayBuffer=30000, mute=false, disablePlayButton=false, disableMuteButton=false, onLineChange=undefined, onPlay=undefined, onPause=undefined, onEnd=undefined }: LyrixCardProps, ref){\n  const [usePlayIcon, setUsePlayIcon] = useState(true);\n  const [muted, setMuted] = useState(mute);\n  const audioRef = useRef<HTMLAudioElement>(null);\n  const lyrixRef = useRef<ActionsHandle>(null);\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      lyrixRef.current?.play();\n    },\n    pause: () => {\n      lyrixRef.current?.pause();\n    },\n    load: () => {\n      audioRef.current?.load();\n    },\n    isPlaying: () => {\n      return lyrixRef.current?.isPlaying() ?? false;\n    }\n  }));\n  const handleOnUserLineChange = (time: number) => {\n    audioRef.current? audioRef.current.currentTime = time : null;\n  }\n  \n  const handleOnPause = () => {\n    audioRef.current?.pause();\n    setUsePlayIcon(true);\n    onPause ? onPause() : null;\n  }\n  \n  const handleOnPlay = (time: number) => {\n    audioRef.current? audioRef.current.currentTime = time : null;\n    audioRef.current?.play();\n    setUsePlayIcon(false);\n    onPlay ? onPlay(time) : null;\n  }\n  const handleOnEnd = () => {\n    lyrixRef.current ? lyrixRef.current.pause() : handleOnPause();\n    onEnd ? onEnd() : null;\n  }\n  const togglePlay = () => {\n    if (lyrixRef.current && lyrixRef.current.isPlaying()) {\n      lyrixRef.current.pause();\n    } else {\n      lyrixRef.current?.play();\n    }\n  }\n  return (\n      <div className={'flex flex-col justify-center items-center gap-12 max-w-xl h-full px-6 py-10 sm:h-fit sm:px-12 sm:py-12 bg-black/5 rounded-2xl shadow-xl ' + className}>\n        <Lyrix \n          ref={lyrixRef}\n          key={0}\n          className=' max-w-full flex-1 sm:flex-none'\n          lyrics={lrc} \n          height={height}\n          start={start} \n          highlightColor={highlightColor}\n          fadeStop={fadeStop}\n          readScrollRatio={scrollRatio}\n          scale={lyricsScale}\n          theme={theme}\n          trailingSpace={trailingSpace}\n          delayEnd={endingDelayBuffer}\n          onUserLineChange={handleOnUserLineChange}\n          onLineChange={onLineChange}\n          onPause={handleOnPause}\n          onPlay={handleOnPlay}\n        />\n        <div className='flex flex-row justify-left items-center h-10 w-full gap-5 mb-[-0.7rem]' >\n          <button onClick={() => togglePlay()} disabled={disablePlayButton} className='bg-transparent border-none outline-none focus:border-none focus:outline-none w-fit p-0 m-[-4px] mb-[-6px]'  style={{color: highlightColor, transform:'scaleX('+controlsScale+') scaleY('+controlsScale+')'}} >\n            {usePlayIcon ? \n              <HiOutlinePlay size={32} /> : \n              <HiOutlinePause size={32} />\n            }\n          </button> \n          <span className='inline-flex h-full items-center flex-1 ' style={{color: highlightColor, fontSize: Math.round(controlsScale*150)/100 + 'rem', lineHeight: '2rem'}}>\n              {title}\n          </span>\n          <button onClick={() => setMuted(!muted)} disabled={disableMuteButton} className='bg-transparent border-none outline-none focus:border-none focus:outline-none w-fit p-0 mb-[-2px]' style={{color: highlightColor, transform:'scaleX('+controlsScale+') scaleY('+controlsScale+')', opacity: disableMuteButton ? 0.5 : 1}}>\n            {muted ?\n              <HiOutlineSpeakerXMark size={28} /> :\n              <HiOutlineSpeakerWave size={28} />\n            }\n          </button>\n        </div>\n        <audio ref={audioRef} src={src} muted={muted} onEnded={handleOnEnd} />\n      </div>\n  )\n});",
      "type": "registry:component"
    },
    {
      "path": "Lyrix.tsx",
      "content": "/** @jsxImportSource @emotion/react */\nimport { css as CSS, Global } from '@emotion/react'\nimport { useEffect, useRef, useState, forwardRef, useImperativeHandle, useCallback, useId } from 'react';\nimport type { CSSObject } from '@emotion/react';\nimport { useTimer } from 'react-use-precision-timer';\nimport { lrcTimestampRegex, processLrcLyrics } from '../lib/processLRC';\nconst googleFonts = `@import url('https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;600;700&family=Roboto:wght@400;500;700&display=swap');`\nexport type ActionsHandle = {\n  play: () => void;\n  pause: () => void;\n  isPlaying: () => boolean;\n}\nexport interface LyrixProps {\n  lyrics: string;\n  className?: string;\n  css?: string | CSSObject;\n  start?: number;\n  highlightColor?: string;\n  timestamps?: number[];\n  height?: string;\n  fade?: boolean;\n  fadeStop?: string;\n  trailingSpace?: string;\n  readScrollRatio?: number;\n  theme?: 'inherit' | 'spotify' | 'lyrix';\n  scale?: number;\n  delayEnd?: number;\n  disableInteractivity?: boolean;\n  onPlay?: (time: number) => void;\n  onPause?: () => void;\n  onUserLineChange?: (line: number, time: number) => void;\n  onLineChange?: (line: number, time: number) => void;\n}\nexport const Lyrix = forwardRef<ActionsHandle, LyrixProps>(function Lyrix({ lyrics, className = '', css = {}, start = 0, highlightColor = '#ffffffbb', height = '', fadeStop = '10ex', trailingSpace = '10rem', timestamps = undefined, readScrollRatio = 1, scale = 1, theme = 'inherit', delayEnd = 10000, disableInteractivity = false, onPause = undefined, onPlay = undefined, onUserLineChange = undefined, onLineChange = undefined }: LyrixProps, ref){\n  const [lyricsArray] = useState<string[]>(lrcTimestampRegex.test(lyrics) ? processLrcLyrics(lyrics).processedLines : lyrics.split('\\n'));\n  const [currentLine, setCurrentLine] = useState<number>(start);\n  const lId = useRef<string>('lyr-ix' + useId());\n  // const callbackAfterRender = useRef<number>(0);\n  // If timestamps are not provided, look for them in the lyrics (lrc format)\n  const timeStamps = timestamps ?? lrcTimestampRegex.test(lyrics) ? processLrcLyrics(lyrics).timestamps : undefined;\n  \n  // Calculate time deltas ie. time between highlighting each line of the lyrics\n  const timeDeltas = timeStamps?.map((timestamp, index) => index + 1 < timeStamps.length? (timeStamps[index + 1] - timestamp) * 1000 : delayEnd);\n  \n  // Callback function for the timer to call at the end of the delay\n  const callback = useCallback(() => setCurrentLine(currentLine => currentLine < lyricsArray.length - 1 ? currentLine + 1 : currentLine), [lyricsArray.length]);\n    \n  // Create the timer\n  const timerRef = useRef(useTimer({ delay: timeDeltas}, callback));\n  \n  const startTimer = useCallback(() => {\n    timerRef.current.start(undefined, currentLine);\n  }, [currentLine]);\n  \n  const pauseTimer = () => {\n    timerRef.current.stop();\n  }\n  // Expose the timer's play and pause methods to the parent component\n  // -------------------------------------------------------------------\n  // I dont know how expensive setting the ref is, but if it is expensive\n  // note that the ref needs to be updated only when currentLine changes.\n  // The current assumption is that setting the ref is not expensive so\n  // the ref is set every render.\n  useImperativeHandle(ref, () => ({\n    play: () => {\n      startTimer();\n      if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n    },\n    pause: () => {\n      pauseTimer();\n      if (onPause) onPause();\n    },\n    isPlaying: () => timerRef.current.isRunning(),\n  }));\n  \n  // Create a keydown event listener to pause/play the timer \n  // (and handle cleanup when the component unmounts)\n  useEffect(() => {\n    if (disableInteractivity) return;\n    function handleKeyDown(e: KeyboardEvent) {\n      if (e.key === ' ' || e.key === 'Spacebar') {\n        e.preventDefault();\n        if (timerRef.current.isRunning()) {\n          pauseTimer();\n          if (onPause) onPause();\n        } else {\n          startTimer();\n          if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n        }\n      }\n      else if (e.shiftKey && e.key === 'Enter') {\n        const lyricsElement = document.getElementById(lId.current);\n        if (e.repeat) {\n          lyricsElement?.scrollTo({ top: lyricsElement.scrollTop - lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n        } else {\n          lyricsElement?.scrollTo({ top: lyricsElement.scrollTop - lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n        }\n      }\n      else if (e.key === 'Enter') {\n        const lyricsElement = document.getElementById(lId.current);\n        lyricsElement?.scrollTo({ top: lyricsElement.scrollTop + lyricsElement.getBoundingClientRect().height, behavior: 'smooth' });\n      }\n      \n      if (e.repeat) {\n        if (e.key === 'Enter'){\n          const lyricsElement = document.getElementById(lId.current);\n          if (e.shiftKey) {\n            lyricsElement?.scrollTo({ top: lyricsElement.scrollTop-=200, behavior: 'auto' });\n          }\n          else {\n            lyricsElement?.scrollTo({ top: lyricsElement.scrollTop+=200, behavior: 'auto' });\n          }\n        }\n      }\n    }\n    document.addEventListener('keydown', handleKeyDown);\n    \n    // Clean up\n    return function cleanup() {\n      document.removeEventListener('keydown', handleKeyDown);\n    }\n  }, [currentLine, timeStamps, onPause, onPlay, startTimer, disableInteractivity]);\n  \n  // Scrolling logic: Scroll to keep the current line in the\n  // desired visible range.\n  // -------------------------------------------------------------------\n  // When the next line that is about to be highlighted exceeds\n  // the readScrollRatio of the height of the lyrics element\n  // the lyrics content must be scrolled down such that the current line\n  // is at the (1-readScrollRatio) of the height of the lyrics element.\n  useEffect(() => {\n    const lyricsElement = document.getElementById(lId.current);\n    const lineElements = document.getElementsByClassName('line');\n    \n    if (lyricsElement && lineElements.length > 0 && lineElements.length === lyricsArray.length && currentLine < lyricsArray.length - 1) {\n      const lyricsClientRects = lyricsElement.getClientRects();\n      const lineClientRects = lineElements[currentLine].getClientRects();\n      const nextLineClientRects = lineElements[currentLine + 1].getClientRects();\n      if (nextLineClientRects[0].bottom > (lyricsClientRects[0].top + readScrollRatio * lyricsClientRects[0].height)) {\n        lyricsElement.scrollTo({ top: lyricsElement.scrollTop + (lineClientRects[0].top - lyricsClientRects[0].top) - (1.0 - readScrollRatio) * lyricsClientRects[0].height, behavior: 'smooth' });\n      }\n      else if (lineClientRects[0].bottom < (lyricsClientRects[0].top + (1.0 - readScrollRatio) * lyricsClientRects[0].height)) {\n        lyricsElement.scrollTo({ top: lyricsElement.scrollTop + (lineClientRects[0].top - lyricsClientRects[0].top) - (1.0 - readScrollRatio) * lyricsClientRects[0].height, behavior: 'smooth' });\n      }\n    }\n  }, [currentLine, lyricsArray.length, readScrollRatio]);\n  \n  // // Warning: Callbacks functions should not be executed during this component's render phase\n  // // because they may cause parent component to re-render at the same time which is\n  // // known to be a source of problems. \n  // // The following useEffect is used to execute pending `onPlay`and `onPause`callbacks after render.\n  // // This is necessary for when the timer is started or paused inside the render phase, ie where the \n  // // callbacks should not be directly called from.\n  // useEffect(() => {\n  //   if (callbackAfterRender.current > 0) {\n  //     if (callbackAfterRender.current === 1) {\n  //       callbackAfterRender.current = 0;\n  //       if (onPlay && timeStamps && timeStamps.length > currentLine) onPlay(timeStamps[currentLine]);\n  //     } else if (callbackAfterRender.current === 2) {\n  //       callbackAfterRender.current = 0;\n  //       if (onPause) onPause();\n  //     }\n  //   }\n  // });\n  \n  // Execute the onLineChange callback when `currentLine` changes after render using useEffect.\n  // Warning: Callbacks functions should not be executed during this component's render phase\n  // because they may cause parent component to re-render at the same time which is\n  // known to be a source of problems.\n  useEffect(() => {\n    onLineChange && onLineChange(currentLine, timeStamps && timeStamps.length > currentLine ? timeStamps[currentLine] : -1);\n  }, [currentLine]);\n  \n  // Add default CSS in an overideable way\n  const completeCSS = typeof css === 'string' ? `display: flex;\n  flex-direction: column;\n  height: ${height};\n  overflow-y: scroll;\n  -ms-overflow-style: none;\n  scrollbar-width: none;\n  -webkit-mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0));\n  mask-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0));\n  & div.line.current {\n    color: ${highlightColor};\n    filter: none;\n}\n${disableInteractivity ? '' : `& div.line:hover {\n  color: ${highlightColor};\n  filter: none;\n  opacity: 1\n}\n`}\n&::-webkit-scrollbar {\n  display: none;\n}\n${theme === 'spotify' ? `& div.line {\n  font-family: 'Heebo', sans-serif;\n  font-size: ${Math.round(scale*20)/10}rem;\n  font-weight: 700;\n  line-height: ${Math.round(scale*24)/10}rem;\n  letter-spacing: -.01em;\n  color: #000000a2;\n  text-align: left;\n  padding-top: ${scale}rem;\n  padding-bottom: ${scale}rem;\n}` : (theme === 'lyrix' ? `& div.line {\n  font-family: 'Roboto', sans-serif;\n  font-size: ${Math.round(scale*20)/10}rem;\n  font-weight: 700;\n  line-height: ${Math.round(scale*24)/10}rem;\n  letter-spacing: -.01em;\n  color: #ffffff;\n  text-align: left;\n  padding-top: ${scale}rem;\n  padding-bottom: ${scale}rem;\n  opacity: 0.2;\n  filter: blur(1px);\n}` : '')}\n${css}` : { display: 'flex', flexDirection: 'column', height: height, overflowY: 'scroll', msOverflowStyle: 'none', scrollbarWidth: 'none', WebkitMaskImage: `linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0))`, maskImage: `linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 1) ${fadeStop}, rgba(0, 0, 0, 1) calc(100% - ${fadeStop}), rgba(0, 0, 0, 0))`, '& div.line.current': { color: highlightColor, filter: 'none', opacity: 1}, '& div.line:hover': disableInteractivity ? undefined : { color: highlightColor, filter: 'none', opacity: 1 }, '&::-webkit-scrollbar': { display: 'none' }, '& div.line': theme === 'spotify' ? { fontFamily:'\"Heebo\", sans-serif', fontSize: Math.round(scale*200)/100 + 'rem', fontWeight: '700', lineHeight: Math.round(scale*240)/100 + 'rem', letterSpacing: '-0.01em', color: '#000000a2', textAlign: 'left', paddingTop: scale + 'rem', paddingBottom: scale + 'rem' } : (theme === 'lyrix' ? { fontFamily:'\"Roboto\", sans-serif', fontSize: Math.round(scale*200)/100 + 'rem', fontWeight: '700', lineHeight: Math.round(scale*240)/100+'rem', letterSpacing: '-0.01em', color: '#ffffff', textAlign: 'left', paddingTop: scale+'rem', paddingBottom: scale+'rem', opacity: 0.2, filter: 'blur(1px)' } : {}), ...css } as CSSObject;\nreturn (\n  <div id={lId.current} className={'lyrics ' + className} css={CSS(completeCSS)} >\n      <Global styles={CSS(googleFonts)} />\n      <div key='space-before' className='spacer' css={CSS({ minHeight: trailingSpace })}></div>\n      {lyricsArray.map((line, index) => (\n        <div\n        key={index}\n        className={'line ' + (index === currentLine ? 'current' : (index < currentLine ? 'past' : 'future'))}\n        onClick={() => {\n          if (disableInteractivity) return;\n          if (currentLine === index) {\n            if (timerRef.current.isRunning()) {\n              pauseTimer();\n              if (onPause) onPause();\n              } else {\n                startTimer();\n                if (onPlay && timeStamps && timeStamps.length > index) onPlay(timeStamps[index]);\n              }\n            } else {\n              pauseTimer();\n              if (onPause) onPause();\n              setCurrentLine(index);\n              if (onUserLineChange) onUserLineChange(index, timeStamps && timeStamps.length > index ? timeStamps[index] : -1);\n            }\n          }}\n          dangerouslySetInnerHTML={{ __html: line.trim()}} \n        />\n      ))}\n      <div key='space-after' className='spacer' css={CSS({ minHeight: trailingSpace })}></div>\n    </div>\n  );\n});\n",
      "type": "registry:component"
    },
    {
      "path": "processLRC.ts",
      "content": "export const lrcTimestampRegex = /\\[(\\d{2}):(\\d{2})\\.(\\d{2,3})\\]/g;\n// Convert LRC lyrics to timestamps and processed lines\nexport const processLrcLyrics = (lyrics: string) => {\n    const lines = lyrics.split('\\n');\n    const timestamps: number[] = [];\n    const processedLines: string[] = [];\n  \n    lines.forEach(line => {\n      const match = lrcTimestampRegex.exec(line);\n      if (match) {\n        timestamps.push((parseInt(match[1]) * 60 * 1000 + parseInt(match[2]) * 1000 + parseInt(match[3])*10) / 1000);\n        processedLines.push(line.replace(lrcTimestampRegex, '').trim());\n      }\n    });\n  \n    return { timestamps, processedLines };\n  }",
      "type": "registry:lib"
    },
    {
      "path": "the-awakening.ts",
      "content": "export const lyrics = `\n[00:00.00]♫\n[00:02.90]If I bleed tonight\n[00:05.40]If I am sad tonight\n[00:08.20]I don't have a job to find\n[00:11.65]And if I work tonight\n[00:14.60]If I'm so tired tonight\n[00:17.67]I'll fall asleep when I'm home\n[00:21.10]When I'm home\n[00:23.78]♫\n[00:42.30]I was just so far from here\n[00:44.62]Focused on my own way\n[00:47.05]Without never looking back\n[00:48.90]To those who lived in fear\n[00:51.88]There was nothing I could do\n[00:53.54]There was nothing you said\n[00:56.20]That could make me realize\n[00:58.38]How much lucky I was\n[01:00.46]Just out of reach of this fire\n[01:02.63]I was not aware of this nightmare\n[01:05.02]But when I start to see those eyes\n[01:06.94]Begging for help and begging for hope\n[01:10.10]I just need to open my eyes now\n[01:11.90]To try to change and to search how\n[01:13.39]To be someone among others\n[01:14.95]I've got to try\n[01:18.30]If I bleed tonight\n[01:20.50]If I am sad tonight\n[01:23.20]I don't have a job to find\n[01:26.92]And if I work tonight\n[01:29.51]If I'm so tired tonight\n[01:32.24]I'll fall asleep when I'm home\n[01:36.01]When I'm home\n[01:38.41]There's no name to call\n[01:40.07]The ones that can't see\n[01:42.38]The light that shines\n[01:44.87]Above their lives\n[01:47.71]I can't say my life is crap\n[01:49.94]I have to see them too\n[01:51.94]I just lived into my world\n[01:53.77]Far from the pain they feel\n[01:55.56]Just out of reach of this fire\n[01:57.62]I was not aware of this nightmare\n[01:59.83]But when I start to see those eyes\n[02:02.05]Begging for help and begging for hope\n[02:04.69]I just need to open my eyes now\n[02:06.92]To try to change and to search how\n[02:09.38]To be someone among others\n[02:11.35]I've got to try\n[02:13.20]If I bleed tonight\n[02:15.75]If I am sad tonight\n[02:18.74]I don't have a job to find\n[02:22.50]And if I work tonight\n[02:25.14]If I'm so tired tonight\n[02:28.12]I'll fall asleep when I'm home\n[02:31.45]I was so wrong\n[02:33.67]I was so blind\n[02:36.06]I was so dumb and out of time\n[02:40.75]I was so wrong\n[02:43.06]I was so blind\n[02:48.47]I was so blind\n[03:13.27]If I bleed tonight\n[03:14.50]If I am sad tonight\n[03:17.57]I don't have a job to find\n[03:21.25]And if I work tonight\n[03:23.80]If I'm so tired tonight\n[03:26.96]I'll fall asleep when I'm home\n[03:31.50]When I'm home\n[03:36.50]When I'm home\n[03:40.90]When I'm home\n[03:46.10]When I'm home\n`;",
      "type": "registry:lib"
    }
  ],
  "tailwind": {},
  "cssVars": {},
  "meta": {
    "importSpecifier": "LyrixCard",
    "moduleSpecifier": "@/components/LyrixCard",
    "nextVersion": "14.2.16"
  },
  "docs": "To import a lyr-ix component, use the following import statement:\n```tsx\nimport { LyrixCard } from '@/components/LyrixCard';\n```\n\nIf errors appear, make sure that the following `emotion` pragma is at the top of `Lyrix.tsx` (in the components directory):\n```tsx\n/** @jsxImportSource @emotion/react */\n```\n\nNote that eslint might complain about some of the terniary expressions. You can edit the eslint config to allow these expressions. Or you can force eslint to ignore `no-unused-expressions` in the file by adding `/* eslint-disable no-unused-expressions */` to the top of the file."
}
